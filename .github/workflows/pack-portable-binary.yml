name: Pack & Release & Deploy Portable Binary

on:
  workflow_dispatch:
  schedule:
    - cron: '15 1 * * *'

permissions:
  contents: write

jobs:
  pack-and-release:
    runs-on: ubuntu-latest
    outputs:
      should_pack: ${{ steps.version_check.outputs.should_pack }}
      github_tag: ${{ steps.get_github_tag.outputs.tag }}
      docker_tag: ${{ steps.get_docker_tag.outputs.tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get latest lobehub/lobe-chat-database docker tag
        id: get_docker_tag
        run: |
          echo "Fetching Docker Hub tags..."
          TAGS_JSON=$(curl -s 'https://registry.hub.docker.com/v2/repositories/lobehub/lobe-chat-database/tags?page_size=100')
          LATEST_VERSION=$(echo "$TAGS_JSON" | jq -r '.results[].name' | \
            grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\.\-]+)?$' | \
            grep -v -E '^(latest|nightly|dev|alpha|beta|rc)$' | \
            sort -rV | \
            head -n1)
          if [ -z "$LATEST_VERSION" ]; then
            echo "No semantic version found, trying alternative patterns..."
            LATEST_VERSION=$(echo "$TAGS_JSON" | jq -r '.results[].name' | \
              grep -E '^[0-9]+\.[0-9]+' | \
              grep -v -E '^(latest|nightly|dev)$' | \
              sort -rV | \
              head -n1)
          fi
          if [ -z "$LATEST_VERSION" ]; then
            echo "ERROR: No valid version tag found in Docker Hub"
            exit 1
          fi
          echo "LATEST_TAG=$LATEST_VERSION" >> $GITHUB_ENV
          echo "tag=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "Docker latest version tag: $LATEST_VERSION"

      - name: Get latest ssfun/lobe-chat-database GitHub release tag
        id: get_github_tag
        run: |
          RESPONSE=$(curl -s -w "\n%{http_code}" 'https://api.github.com/repos/ssfun/lobe-chat-database/releases/latest')
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          if [ "$HTTP_CODE" = "404" ]; then
            GITHUB_TAG="v0.0.0"
          elif [ "$HTTP_CODE" = "200" ]; then
            GITHUB_TAG=$(echo "$BODY" | jq -r '.tag_name')
            if [ "$GITHUB_TAG" = "null" ] || [ -z "$GITHUB_TAG" ]; then
              GITHUB_TAG="v0.0.0"
            fi
          else
            GITHUB_TAG=$(curl -s 'https://api.github.com/repos/ssfun/lobe-chat-database/tags' | \
              jq -r '.[].name' | \
              grep -E '^v?[0-9]+\.[0-9]+' | \
              sort -rV | \
              head -n1)
            if [ -z "$GITHUB_TAG" ]; then
              GITHUB_TAG="v0.0.0"
            fi
          fi
          echo "GITHUB_TAG=$GITHUB_TAG" >> $GITHUB_ENV
          echo "tag=$GITHUB_TAG" >> $GITHUB_OUTPUT
          echo "GitHub latest tag: $GITHUB_TAG"

      - name: Compare versions and decide if packing is needed
        id: version_check
        run: |
          DOCKER_VERSION="${LATEST_TAG#v}"
          GITHUB_VERSION="${GITHUB_TAG#v}"
          echo "Docker version: $DOCKER_VERSION, GitHub version: $GITHUB_VERSION"
          version_gt() {
            [ "$(printf '%s\n' "$1" "$2" | sort -V | head -n1)" != "$1" ]
          }
          if [ "$DOCKER_VERSION" = "$GITHUB_VERSION" ]; then
            echo "Versions are identical, no need to pack"
            echo "should_pack=false" >> $GITHUB_OUTPUT
          elif version_gt "$DOCKER_VERSION" "$GITHUB_VERSION"; then
            echo "Docker version is newer, proceeding to pack"
            echo "should_pack=true" >> $GITHUB_OUTPUT
          else
            echo "Docker version is not newer"
            echo "should_pack=false" >> $GITHUB_OUTPUT
          fi

  pack-binaries:
    needs: pack-and-release
    if: needs.pack-and-release.outputs.should_pack == 'true'
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.set_release_output.outputs.release_created }}
      version_tag: ${{ needs.pack-and-release.outputs.docker_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up dependencies for dockerc
        run: |
          sudo apt-get update
          sudo apt-get install -y fuse overlayroot squashfs-tools skopeo jq curl

      - name: Download dockerc
        run: |
          wget -O dockerc https://github.com/NilsIrl/dockerc/releases/download/v0.3.2/dockerc_x86-64
          chmod +x ./dockerc

      - name: Pack linux/amd64
        run: |
          ./dockerc --image docker://lobehub/lobe-chat-database:${{ needs.pack-and-release.outputs.docker_tag }} \
            --arch amd64 \
            --output lobe-chat-${{ needs.pack-and-release.outputs.docker_tag }}-linux-amd64.bin

      - name: Pack linux/arm64
        run: |
          ./dockerc --image docker://lobehub/lobe-chat-database:${{ needs.pack-and-release.outputs.docker_tag }} \
            --arch arm64 \
            --output lobe-chat-${{ needs.pack-and-release.outputs.docker_tag }}-linux-arm64.bin

      - name: Generate SHA256 checksums
        run: |
          sha256sum lobe-chat-*.bin > checksums.txt

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.pack-and-release.outputs.docker_tag }}
          files: |
            lobe-chat-*.bin
            checksums.txt
          token: ${{ secrets.GITHUB_TOKEN }}
          title: "Release ${{ needs.pack-and-release.outputs.docker_tag }}"
          body: |
            Automated Release for ${{ needs.pack-and-release.outputs.docker_tag }}

      - name: Set release output
        id: set_release_output
        if: always()
        run: |
          if [ "${{ steps.create_release.outcome }}" == "success" ]; then
            echo "release_created=true" >> $GITHUB_OUTPUT
          else
            echo "release_created=false" >> $GITHUB_OUTPUT
          fi

  deploy-to-server:
    needs: [pack-binaries]
    if: |
      always() && 
      needs.pack-binaries.result == 'success' && 
      needs.pack-binaries.outputs.release_created == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        server: [server1]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to ${{ matrix.server }}
        env:
          SERVER_HOST: ${{ secrets[format('{0}_HOST', matrix.server)] }}
          SERVER_USER: ${{ secrets[format('{0}_USER', matrix.server)] }}
          SERVER_PASSWORD: ${{ secrets[format('{0}_PASSWORD', matrix.server)] }}
          SERVER_PORT: ${{ secrets[format('{0}_PORT', matrix.server)] || '22' }}
          LOBE_CHAT_ENV: ${{ secrets[format('{0}_LOBE_CHAT_ENV', matrix.server)] || '' }}
          VERSION_TAG: ${{ needs.pack-binaries.outputs.version_tag }}
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass
          
          echo "Deploying version ${VERSION_TAG} to ${SERVER_HOST}"
          
          # [ÊúÄÁªà‰øÆÂ§ç] ‰ΩøÁî® screen ÁöÑÊúÄÁªàÈÉ®ÁΩ≤ËÑöÊú¨
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          VERSION_TAG="${1}"
          shift
          LOBE_CHAT_ENV="$@"
          
          echo "========================================="
          echo "Starting deployment using screen"
          echo "Version: ${VERSION_TAG}"
          echo "========================================="
          
          SUDO_CMD=""
          if [ "$EUID" -ne 0 ]; then
            if command -v sudo >/dev/null 2>&1 && sudo -n true 2>/dev/null; then
              SUDO_CMD="sudo"
            fi
          fi
          
          # Á°Æ‰øù screen Âíå ss Â∑≤ÂÆâË£Ö
          echo "Ensuring screen and iproute2 are installed..."
          ${SUDO_CMD} apt-get update
          ${SUDO_CMD} apt-get install -y screen iproute2
          
          # ÂÅúÊ≠¢ÊóßÁöÑ lobe-chat ËøõÁ®ã (‰Ωú‰∏∫‰øùÈô©)
          pkill -f "/opt/lobe-chat/lobe-chat.bin" || true
          
          # ÂÅúÊ≠¢ÊóßÁöÑ screen ‰ºöËØù
          if screen -list | grep -q "lobe-chat"; then
            echo "Stopping old screen session..."
            screen -S lobe-chat -X quit || true
            sleep 2
          fi
          
          # ‰∏ãËΩΩÂíåÂÆâË£Ö‰∫åËøõÂà∂Êñá‰ª∂
          ARCH=$(uname -m)
          case ${ARCH} in
            x86_64) BINARY_ARCH="amd64" ;;
            aarch64|arm64) BINARY_ARCH="arm64" ;;
            *) echo "ERROR: Unsupported architecture: ${ARCH}"; exit 1 ;;
          esac
          DOWNLOAD_URL="https://github.com/ssfun/lobe-chat-database/releases/download/${VERSION_TAG}/lobe-chat-${VERSION_TAG}-linux-${BINARY_ARCH}.bin"
          TEMP_DIR=$(mktemp -d)
          cd ${TEMP_DIR}
          echo "Downloading from ${DOWNLOAD_URL}..."
          wget -q --show-progress -O lobe-chat.bin "${DOWNLOAD_URL}"
          
          ${SUDO_CMD} mkdir -p /opt/lobe-chat
          if [ -f "/opt/lobe-chat/lobe-chat.bin" ]; then
            ${SUDO_CMD} mv /opt/lobe-chat/lobe-chat.bin "/opt/lobe-chat/lobe-chat.bin.backup.$(date +%Y%m%d_%H%M%S)"
          fi
          ${SUDO_CMD} mv lobe-chat.bin /opt/lobe-chat/lobe-chat.bin
          ${SUDO_CMD} chmod +x /opt/lobe-chat/lobe-chat.bin
          cd / && rm -rf ${TEMP_DIR}
          
          # ÊûÑÂª∫ÂêØÂä®ÂëΩ‰ª§
          START_CMD="/opt/lobe-chat/lobe-chat.bin"
          if [ ! -z "${LOBE_CHAT_ENV}" ]; then
            if echo "${LOBE_CHAT_ENV}" | grep -q "^\-e "; then
              START_CMD="${START_CMD} ${LOBE_CHAT_ENV}"
            else
              ENV_ARGS=""
              for env_pair in ${LOBE_CHAT_ENV}; do
                if [ ! -z "$env_pair" ] && echo "$env_pair" | grep -q '='; then
                  ENV_ARGS="${ENV_ARGS} -e ${env_pair}"
                fi
              done
              START_CMD="${START_CMD} ${ENV_ARGS}"
            fi
          fi
          
          LOG_FILE="/opt/lobe-chat/lobe-chat.log"
          
          # ‰ΩøÁî® screen Âú®ÂêéÂè∞ÂêØÂä®ÊúçÂä°
          echo "Starting service inside a new screen session 'lobe-chat'..."
          screen -dmS lobe-chat bash -c "${START_CMD} > ${LOG_FILE} 2>&1"
          
          # ÂÅ•Â∫∑Ê£ÄÊü•
          echo "Waiting for service to be ready... (up to 20s)"
          SUCCESS=false
          for i in {1..10}; do
            if pgrep -f "/opt/lobe-chat/lobe-chat.bin" > /dev/null && ss -tlpn | grep -q ':3210'; then
              echo "‚úÖ Service is running and listening on port 3210."
              SUCCESS=true
              break
            fi
            echo "Waiting... ($i/10)"
            sleep 2
          done
          
          if [ "${SUCCESS}" = "true" ]; then
            echo "Deployment successful!"
            exit 0
          else
            echo "‚ùå ERROR: Deployment Failed"
            echo "Service failed to start or listen on port 3210."
            echo "Error logs (last 50 lines from ${LOG_FILE}):"
            tail -n 50 ${LOG_FILE} 2>/dev/null || echo "Log file not found or empty."
            exit 1
          fi
          EOF

          # ‰ΩøÁî®ÂéüÂßã ssh ÂëΩ‰ª§ (‰∏çÂ∏¶ -tt)
          if sshpass -p "${SERVER_PASSWORD}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -p ${SERVER_PORT} ${SERVER_USER}@${SERVER_HOST} \
            "bash -s" < deploy.sh "${VERSION_TAG}" "${LOBE_CHAT_ENV}"; then
            echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_ENV
            echo "::notice ::‚úÖ Deployment to ${SERVER_HOST} completed successfully"
          else
            echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_ENV
            echo "::error ::‚ùå Deployment to ${SERVER_HOST} failed"
            exit 1
          fi

      - name: Send Telegram notification
        if: env.DEPLOYMENT_SUCCESS == 'true'
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          VERSION_TAG: ${{ needs.pack-binaries.outputs.version_tag }}
          SERVER_NAME: ${{ matrix.server }}
        run: |
          if [ ! -z "${TELEGRAM_BOT_TOKEN}" ] && [ ! -z "${TELEGRAM_CHAT_ID}" ]; then
            MESSAGE=$(cat <<-END
            {
              "chat_id": "${TELEGRAM_CHAT_ID}",
              "parse_mode": "Markdown",
              "disable_web_page_preview": true,
              "text": "üöÄ *Lobe Chat Deployment Success*\n\nüì¶ *Version:* \`${VERSION_TAG}\`\nüñ•Ô∏è *Server:* ${SERVER_NAME}\n‚è∞ *Time:* $(date -u '+%Y-%m-%d %H:%M:%S UTC')\n‚úÖ *Status:* Deployed and running\n\nüîó [View Release](https://github.com/ssfun/lobe-chat-database/releases/tag/${VERSION_TAG})"
            }
            END
            )
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -H "Content-Type: application/json" \
              -d "${MESSAGE}"
          fi

  notify-failure:
    needs: [pack-binaries, deploy-to-server]
    if: |
      always() && 
      (needs.pack-binaries.result == 'failure' || needs.deploy-to-server.result == 'failure')
    runs-on: ubuntu-latest
    steps:
      - name: Send failure notification
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          if [ ! -z "${TELEGRAM_BOT_TOKEN}" ] && [ ! -z "${TELEGRAM_CHAT_ID}" ]; then
            FAILED_STAGE=""
            if [ "${{ needs.pack-binaries.result }}" == "failure" ]; then
              FAILED_STAGE="Pack & Release"
            elif [ "${{ needs.deploy-to-server.result }}" == "failure" ]; then
              FAILED_STAGE="Deployment"
            else
              FAILED_STAGE="Unknown"
            fi
            MESSAGE=$(cat <<-END
            {
              "chat_id": "${TELEGRAM_CHAT_ID}",
              "parse_mode": "Markdown",
              "text": "‚ùå *Lobe Chat Pipeline Failed*\n\n‚ö†Ô∏è *Failed Stage:* ${FAILED_STAGE}\n‚è∞ *Time:* $(date -u '+%Y-%m-%d %H:%M:%S UTC')\nüìù *Workflow:* ${{ github.workflow }}\nüîó [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
            }
            END
            )
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -H "Content-Type: application/json" \
              -d "${MESSAGE}"
          fi
